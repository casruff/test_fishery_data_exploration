---
title: PS Chum Test Fishery Data Exploration
author: Thomas Buehrens (tbuehrens@dfw.wa.gov), Matthew Bogaard (matthew.bogaard@dfw.wa.gov), & Mickey Agha (mickey.agha@dfw.wa.gov)
output:
  html_document:
    code_folding: hide
    fig_caption: yes
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
---
  
  ***
  
  Last Updated `r format(Sys.time(), '%m/%d/%Y')`.

***
  
  
# Overview
This script fits Generalized Additive Models to Skagit Steelhead Test Fishery Data with and without the Total Run Size as an offset. The best model without TRS as an offset includes a spline term for year, which attempts to explain the residual variance (e.g., due to inter-annual run size differences) when the TRS offset is removed. Therefore, this spline term may be considered somewhat analogous to the model's ability to predict runsize based on the in-season test fishery data. A prediction of Total Run Size may be obtained by multiplying this fitted value of this year term (holding all other terms to zero) by the mean annual run size. Predictions from this approach, including 95%CI are compared with observed TRS, demonstrating the efficacy of using in-season test fishery data to estimate Total Run Size.

The code repository used to generate this page and complete analyses can be found here: [**(link)**](https://github.com/casruff/test_fishery_data_exploration)

## Setup
All analyses require R software [**(link)**](https://cran.r-project.org/) (v3.4.3) for data retrieval, data processing, and summarizing model results. Here we configure R to perform our analysis and generate our outputs
```{r set_options, echo = TRUE, message = FALSE}
options(width = 100)
knitr::opts_chunk$set(message = FALSE)
set.seed(123)
```

We also need a couple of helper functions which we will define
```{r load_funcs, message = FALSE, warning = FALSE,results = "hide"}
#function to install or load packages
install_or_load_pack <- function(pack){
  create.pkg <- pack[!(pack %in% installed.packages()[, "Package"])]
  if (length(create.pkg))
    install.packages(create.pkg, dependencies = TRUE)
  sapply(pack, require, character.only = TRUE)
}

```

Here we will load & install packages we need to use (needs internet connection if packages not already installed)
```{r load_packages, message = FALSE, warning = FALSE,results = "hide"}
packages_list<-c("tidyverse"
                 ,"forecast"
                 ,"mgcv"
                 ,"ggplot2"
                 ,"MASS"
                 ,"RColorBrewer"
                 ,"kableExtra"
                 ,"gtools"
                 ,"readr"
                 ,"here"
                 ,"readxl"
                 ,"brms"
                 ,"bsplus"
                 ,"lubridate"
                 ,"MuMIn"
                 ,"tidymv"
                 ,"modelr"
                 ,"R2jags"
                 ,"kableExtra"
                 # ,"rnoaa"
                 # ,"ncdf4"
                 # ,"ncdf4.helpers"
                 # ,"raster"
                 ,"reshape2"
                 # ,"ggfortify"
                 )
install_or_load_pack(pack = packages_list)
```

## User Inputs
Here we will specify the years of analysis, identify data file names and the flow gauge to be used.
```{r user_inputs, message = FALSE, warning = FALSE,results = "show"}
## set data dir
datadir <- here("data")
modeldir <- here("jags")

## first & last years of fish data
yr_frst <- 2013
yr_last <- 2022


## data file names
## 1. file with escapement data
fn_trs <- "chum_trs.csv"

## 2. file with age comp data
fn_tst_fsh <- "chum_CPUE_cov.csv"

```

## Load Data
In this section we will load 1) the Total Run Size data, 2) the Test Fishery Data, and 3) The flow data.
```{r load_data, message = FALSE, warning = FALSE,results = "show"}
## read total runsize data
dat_trs <- read_csv(file.path(datadir,fn_trs))%>%
  dplyr::select(year,trs=AllSS_Wild)
## read in test fishery data
dat_tst_fsh <- read_csv(file.path(datadir,fn_tst_fsh))%>%
  mutate(date = mdy(date))

```

## Analysis by set 
Here we will combine the three datasets, fit a series of gam models with spline terms for day of year, interactions between day of year and year (e.g., time-varying run timing), and random effects for set number. Here the response variable is catch per per net set. Offset terms include the Total Run Size. Once a "best model" is fit, the best model is refit dropping the offset for Total Runsize and is then used to predict total run size (using the mean(log(runsize)) as an offset. Predictions are compared with observations. 

Results shown include:
1) the model selection table 
2) the summary statistics for the best model
3) plots of the spline terms on the link scale for the best model
4) the "gam.check" plots for goodness of fit and GOF statistics table
5) The model selection table including the best model re-fit without the TRS offset
6) a plot of the predicted relative CPUE by day of year for an average year from the best model
7) the best model's forecast of TRS compared with observations
```{r Analysis, message = FALSE, warning = FALSE,results = "show"}
dat<-dat_tst_fsh%>%
  left_join(dat_trs)%>%
  mutate(ml_trs = mean(log(unique(trs)),na.rm = TRUE)
  )


m1<-gam(count ~ s(day,bs="cc",k=5) + s(set,bs="re"), offset=log(trs), knots = list(day = seq(270,340,length.out=5)),family = nb(theta = NULL, link = "log"),data=dat)

m2<-gam(count ~   s(day,bs="cc",k=5)+ s(year) + s(set,bs="re"), offset=log(trs),knots = list(day = seq(270,340,length.out=5)), family = nb(theta = NULL, link = "log"),data=dat)

m3<-gam(count ~   s(day,bs="cc",k=5) + ti(day,year,bs=c("cc","ps")) + s(set,bs="re"), offset=log(trs), knots = list(day = seq(270,340,length.out=5)),family = nb(theta = NULL, link = "log"),data=dat)


model.sel(m1,m2,m3)


summary(m3)
plot(m3)
gam.check(m3)
plot(m3$y~ m3$fitted.values)
abline(a=0,b=1)

#best model removing offset of total run size, adding a year spline...this term should explain variance accounted for previously by offset term

m3b<-gam(count ~   s(day,bs="cc",k=5) + ti(day,year,bs=c("cc","ps")) + s(set,bs='re') + as.factor(year), offset=log(ml_trs), knots = list(day = seq(270,340,length.out=5)),family = nb(theta = NULL, link = "log"),data=dat)


#what does year spline term look like?
# plot(m3b,select = 5,shade=T)

#add a relative CPUE plot
newdat<-expand.grid(day=seq(min(dat$day),max(dat$day),by=1),
                    year=seq(min(dat$year),max(dat$year),by=1),
                    effort = 7,
                    set = 1,
                    trs = exp(median(dat$ml_trs))
)%>%
  as.tibble()%>%
  add_predictions(m3,var="pred")%>%
  mutate(pred = exp(pred + log(effort) + log(trs)))%>%
  mutate(relative_CPUE = pred/max(pred))

ggplot(newdat,aes(x=day,y=relative_CPUE,color=as.factor(year)))+
  geom_line()+
  scale_y_log10()
  #ylim(0,1)

#what does model predict trs is each year?
newdat<-dat_trs%>%
  mutate(day=300,
         set = 1,
         year = year,
         ml_trs = 0,
  )%>%filter(year %in% unique(dat_tst_fsh$year))

preds_yr<-predict.gam(m3b, newdata=newdat, type = "terms", exclude = c("s(day)","ti(day,year)","s(set)"), newdata.guaranteed=TRUE, se.fit=T)



preds<-data.frame(mle=c(exp(preds_yr$fit - mean(preds_yr$fit) + median(dat$ml_trs))),
                  l95=c(exp(preds_yr$fit - mean(preds_yr$fit) - 1.96 * preds_yr$se + median(dat$ml_trs))),
                  u95=c(exp(preds_yr$fit - mean(preds_yr$fit) + 1.96 * preds_yr$se + median(dat$ml_trs))),
                  l50=c(exp(preds_yr$fit - mean(preds_yr$fit) - 0.6744898 * preds_yr$se + median(dat$ml_trs))),
                  u50=c(exp(preds_yr$fit - mean(preds_yr$fit) + 0.6744898 * preds_yr$se + median(dat$ml_trs)))
)


newdat<-newdat%>%
  bind_cols(preds)%>%
  mutate(error = mle - trs)


ggplot(data=newdat,aes(x=year, y=trs))+
  geom_ribbon(mapping=aes(x=year,ymin=l95,ymax=u95),fill="blue",color=NA,alpha=0.5)+
  geom_ribbon(mapping=aes(x=year,ymin=l50,ymax=u50),fill="blue",color=NA,alpha=0.5)+
  geom_line(mapping=aes(x=year,y=mle),color="blue")+
  geom_point(size=2)+
  geom_point(mapping=aes(x=year,y=mle),size=1.3, color ="blue")+
  ylim(0,NA)

newdat%>%
  dplyr::select(year,trs,mle,l50,u50,l95,u95)%>%
  kbl(caption = "Table 1. Predicted vs. observed TRS",digits =0)%>%
  kable_classic(full_width = F, html_font = "Cambria")

print(newdat%>%
        summarize(
          me = mean(error),
          mae = mean(abs(error)),
          mae = mean(error/trs)*100,
          mape = mean(abs(error)/trs) * 100,
                 rmse = sqrt(mean(error^2)),
          mase = mean(abs(error))/mean(abs(diff(trs)))
                  )%>%
        print()
)
```

## Analysis by date/location (pooling sets)
Here we will combine the three datasets, fit a series of gam models with spline terms for day of year, interactions between day of year and year (e.g., time-varying run timing), and random effects for set number. Here the response variable is catch per per net set. Offset terms include the Total Run Size. Once a "best model" is fit, the best model is refit dropping the offset for Total Runsize and is then used to predict total run size (using the mean(log(runsize)) as an offset. Predictions are compared with observations.

Results shown include:
1) the model selection table 
2) the summary statistics for the best model
3) plots of the spline terms on the link scale for the best model
4) the "gam.check" plots for goodness of fit and GOF statistics table
5) The model selection table including the best model re-fit without the TRS offset
6) the best model's forecast of TRS compared with observations
```{r Analysis_v2, message = FALSE, warning = FALSE,results = "show"}
dat<-dat_tst_fsh%>%
  left_join(dat_trs)%>%
  mutate( ml_trs = mean(log(unique(trs)),na.rm = TRUE)
         )%>%
  group_by(year,day,ml_trs,trs)%>%
  summarise(count = sum(count),
           effort = max(set),
           ml_trs = first(ml_trs))

#raw data plot
ggplot(dat%>%mutate(CPUE =count/effort),aes(y=CPUE,x=day,color=as.factor(year)))+geom_line()+facet_wrap(~year)
  
m1<-gam(count ~  s(day,k=5,bs="cc"), offset=log(trs) + log(effort), knots = list(day = seq(270,340,length.out=5)), family = nb(theta = NULL, link = "log"),data=dat)

m2<-gam(count ~  s(day,k=5,bs="cc") + s(year,bs="ps"), offset=log(trs) + log(effort), knots = list(day = seq(270,340,length.out=5)), family = nb(theta = NULL, link = "log"),data=dat)

m3<-gam(count ~  s(day,k=5,bs="cc") + ti(day,year), offset=log(trs) + log(effort), knots = list(day = seq(270,340,length.out=5)),family = nb(theta = NULL, link = "log"),data=dat)


model.sel(m1,m2,m3)


summary(m3)
plot(m3)
gam.check(m3)
plot(m3$y~ m3$fitted.values)
abline(a=0,b=1)
#best model removing offset of total run size, adding a year spline...this term should explain variance accounted for previously by offset term

m3b<-gam(count ~  s(day,k=5,bs="cc") + ti(day,year) + as.factor(year), offset=log(ml_trs) + log(effort), knots = list(day = seq(270,340,length.out=5)), family = nb(theta = NULL, link = "log"),data=dat)

m1b<-gam(count ~  s(day,k=5,bs="cc") + as.factor(year), offset=log(ml_trs) + log(effort),  knots = list(day = seq(270,340,length.out=5)),family = nb(theta = NULL, link = "log"),data=dat)


#add a relative CPUE plot
newdat<-expand.grid(day=seq(min(dat$day),max(dat$day),by=1),
                    year=seq(min(dat$year),max(dat$year),by=1),
                    effort = 7,
                    trs = exp(median(dat$ml_trs))
)%>%
  as.tibble()%>%
  add_predictions(m3,var="pred")%>%
  mutate(pred = exp(pred + log(effort) + log(trs)))%>%
  mutate(relative_CPUE = pred/max(pred))

ggplot(newdat,aes(x=day,y=relative_CPUE,color=as.factor(year)))+
  geom_line()+
  ylim(0,1)



#what does model predict trs is each year?
newdat<-dat_trs%>%
  mutate(day=1,
         year = year,
         effort = 1,
         )%>%
  filter(year %in% unique(dat_tst_fsh$year))

preds_yr<-predict.gam(m1b, newdata=newdat, type = "iterms", exclude = c("s(day)"), newdata.guaranteed=TRUE, se.fit=T)

preds<-data.frame(mle=c(exp(preds_yr$fit - mean(preds_yr$fit) + median(dat$ml_trs))),
                  l95=c(exp(preds_yr$fit - mean(preds_yr$fit) - 1.96 * preds_yr$se + median(dat$ml_trs))),
                  u95=c(exp(preds_yr$fit - mean(preds_yr$fit) + 1.96 * preds_yr$se + median(dat$ml_trs))),
                  l50=c(exp(preds_yr$fit - mean(preds_yr$fit) - 0.6744898 * preds_yr$se + median(dat$ml_trs))),
                  u50=c(exp(preds_yr$fit - mean(preds_yr$fit) + 0.6744898 * preds_yr$se + median(dat$ml_trs)))
)


newdat<-newdat%>%
  bind_cols(preds)%>%
  mutate(error = mle - trs)
  

ggplot(data=newdat,aes(x=year, y=trs))+
  geom_ribbon(mapping=aes(x=year,ymin=l95,ymax=u95),fill="blue",color=NA,alpha=0.5)+
  geom_ribbon(mapping=aes(x=year,ymin=l50,ymax=u50),fill="blue",color=NA,alpha=0.5)+
  geom_line(mapping=aes(x=year,y=mle),color="blue")+
  geom_point(size=2)+
  geom_point(mapping=aes(x=year,y=mle),size=1.3, color ="blue")+
  #scale_y_log10()
  ylim(1,NA)

newdat%>%
  dplyr::select(year,trs,mle,l50,u50,l95,u95)%>%
  kbl(caption = "Table 2. Predicted vs. observed TRS",digits =0)%>%
  kable_classic(full_width = F, html_font = "Cambria")

print(newdat%>%
        summarize(
          ME = mean(error),
          MAE = mean(abs(error)),
          MAE = mean(error/trs)*100,
          MAPE = mean(abs(error)/trs) * 100,
                 rmse = sqrt(mean(error^2)),
          MASE = mean(abs(error))/mean(abs(diff(trs)))
                  )%>%
        print()
)

```

# Alternative Approach 

model with trs as response variable....use CPUE as covariate....no fancy observation model, requires consistent data (no missing, no zeros)
```{r Analysis_v3, message = FALSE, warning = FALSE,results = "show"}

#look at data to see consistency
dat_tst_fsh%>%
  group_by(year,day,date,week)%>%
  summarise(count = sum(count),
           effort = max(set)
           )%>%
  left_join(dat_trs)%>%
  group_by(year,week)%>%
  summarise(n = n()
            )%>%
  pivot_wider(names_from = week,values_from = n)%>%
  dplyr::select(sort(current_vars()))%>%
  data.frame()



dat<-dat_tst_fsh%>%
  group_by(year,day,date,week)%>%
  summarise(count = sum(count),
           effort = max(set)
           )%>%
  left_join(dat_trs)%>%
  mutate(CPUE = count/effort
         )%>%
  filter(week %in%c(42:46))%>%
  group_by(year,trs)%>%
  summarise(
    n = n(),
    geomean_CPUE = exp(log(sum(CPUE)) - log(n))
  )

m1<-auto.arima(dat$trs, xreg=log(dat$geomean_CPUE), lambda = 0)

results<-tibble(year=dat$year,
                trs=dat$trs,
                mle=m1$fitted, 
                l95 = exp(qnorm(0.025,log(m1$fitted),sqrt(m1$sigma2))), 
                u95 = exp(qnorm(0.975,log(m1$fitted),sqrt(m1$sigma2))),
                l50 = exp(qnorm(0.25,log(m1$fitted),sqrt(m1$sigma2))), 
                u50 = exp(qnorm(0.75,log(m1$fitted),sqrt(m1$sigma2))),
                )

ggplot(results,aes(x=year,y=trs))+
  geom_ribbon(aes(x=year,ymin=l95,ymax=u95),fill="cadetblue",color=NA,alpha=0.5)+
  geom_ribbon(aes(x=year,ymin=l50,ymax=u50),fill="cadetblue",color=NA,alpha=0.5)+
  geom_line(aes(x=year,y=mle),color="cadetblue")+
  geom_point(aes(x=year,y=mle),color="cadetblue")+
  geom_point(aes(x=year,y=trs))

results%>%
  dplyr::select(year,trs,mle,l50,u50,l95,u95)%>%
  kbl(caption = "Table 2. Predicted vs. observed TRS",digits =0)%>%
  kable_classic(full_width = F, html_font = "Cambria")

print(summary(m1))



```

